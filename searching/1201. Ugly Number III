class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {

           long MOD = 1_000_000_007;
        long la = (long) a, lb = (long) b, lc = (long) c;

        // LCM calculations using the helper function
        long lcmAB = lcm(la, lb);
        long lcmAC = lcm(la, lc);
        long lcmBC = lcm(lb, lc);
        long lcmABC = lcm(lcmAB, lc);

        long start = 1, end = (long) n * Math.min(a, Math.min(b, c));

        // Perform binary search
        while (start < end) {
            long mid = start + (end - start) / 2;
            long count = countUgly(la, lb, lc, lcmAB, lcmAC, lcmBC, lcmABC, mid);
            if (count < n) {
                start = mid + 1; // Move to the right half
            } else {
                end = mid; // Move to the left half
            }
        }

        return (int) (start % MOD); // Final result modulo 1_000_000_007
    }

    // Helper function to compute LCM
    private long lcm(long x, long y) {
        return x * (y / gcd(x, y)); // Avoid overflow with x * (y / gcd)
    }

    // Helper function to compute GCD
    private long gcd(long x, long y) {
        return y == 0 ? x : gcd(y, x % y); // Standard Euclidean algorithm
    }

    // Function to count how many numbers <= x are divisible by a, b, or c
    private long countUgly(long a, long b, long c, long lcmAB, long lcmAC, long lcmBC, long lcmABC, long x) {
        // Apply modulo to prevent large intermediate results
        return (x / a) + (x / b) + (x / c)
               - (x / lcmAB) - (x / lcmAC) - (x / lcmBC)
               + (x / lcmABC);
    }
}
